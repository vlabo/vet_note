// Code generated by BobGen sqlite v0.31.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"hash/maphash"
	"strings"

	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/clause"
	"github.com/stephenafamo/bob/dialect/sqlite"
	"github.com/stephenafamo/bob/dialect/sqlite/dialect"
	sqliteDriver "modernc.org/sqlite"
)

var TableNames = struct {
	Patients   string
	Procedures string
	Settings   string
}{
	Patients:   "patients",
	Procedures: "procedures",
	Settings:   "settings",
}

var ColumnNames = struct {
	Patients   patientColumnNames
	Procedures procedureColumnNames
	Settings   settingColumnNames
}{
	Patients: patientColumnNames{
		ID:          "id",
		Type:        "type",
		Name:        "name",
		Gender:      "gender",
		Age:         "age",
		ChipID:      "chip_id",
		Weight:      "weight",
		Castrated:   "castrated",
		Note:        "note",
		Owner:       "owner",
		OwnerPhone:  "owner_phone",
		Folder:      "folder",
		IndexFolder: "index_folder",
		CreatedAt:   "created_at",
		UpdatedAt:   "updated_at",
		DeletedAt:   "deleted_at",
	},
	Procedures: procedureColumnNames{
		ID:        "id",
		Type:      "type",
		Date:      "date",
		Details:   "details",
		PatientID: "patient_id",
		CreatedAt: "created_at",
		UpdatedAt: "updated_at",
		DeletedAt: "deleted_at",
	},
	Settings: settingColumnNames{
		ID:        "id",
		Value:     "value",
		Type:      "type",
		Idx:       "idx",
		CreatedAt: "created_at",
		UpdatedAt: "updated_at",
		DeletedAt: "deleted_at",
	},
}

var (
	SelectWhere = Where[*dialect.SelectQuery]()
	InsertWhere = Where[*dialect.InsertQuery]()
	UpdateWhere = Where[*dialect.UpdateQuery]()
	DeleteWhere = Where[*dialect.DeleteQuery]()
)

func Where[Q sqlite.Filterable]() struct {
	Patients   patientWhere[Q]
	Procedures procedureWhere[Q]
	Settings   settingWhere[Q]
} {
	return struct {
		Patients   patientWhere[Q]
		Procedures procedureWhere[Q]
		Settings   settingWhere[Q]
	}{
		Patients:   buildPatientWhere[Q](PatientColumns),
		Procedures: buildProcedureWhere[Q](ProcedureColumns),
		Settings:   buildSettingWhere[Q](SettingColumns),
	}
}

var (
	SelectJoins = getJoins[*dialect.SelectQuery]
	UpdateJoins = getJoins[*dialect.UpdateQuery]
)

type joinSet[Q interface{ aliasedAs(string) Q }] struct {
	InnerJoin Q
	LeftJoin  Q
	RightJoin Q
}

func (j joinSet[Q]) AliasedAs(alias string) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: j.InnerJoin.aliasedAs(alias),
		LeftJoin:  j.LeftJoin.aliasedAs(alias),
		RightJoin: j.RightJoin.aliasedAs(alias),
	}
}

type joins[Q dialect.Joinable] struct {
	Patients   joinSet[patientJoins[Q]]
	Procedures joinSet[procedureJoins[Q]]
}

func buildJoinSet[Q interface{ aliasedAs(string) Q }, C any, F func(C, string) Q](c C, f F) joinSet[Q] {
	return joinSet[Q]{
		InnerJoin: f(c, clause.InnerJoin),
		LeftJoin:  f(c, clause.LeftJoin),
		RightJoin: f(c, clause.RightJoin),
	}
}

func getJoins[Q dialect.Joinable]() joins[Q] {
	return joins[Q]{
		Patients:   buildJoinSet[patientJoins[Q]](PatientColumns, buildPatientJoins),
		Procedures: buildJoinSet[procedureJoins[Q]](ProcedureColumns, buildProcedureJoins),
	}
}

type modAs[Q any, C interface{ AliasedAs(string) C }] struct {
	c C
	f func(C) bob.Mod[Q]
}

func (m modAs[Q, C]) Apply(q Q) {
	m.f(m.c).Apply(q)
}

func (m modAs[Q, C]) AliasedAs(alias string) bob.Mod[Q] {
	m.c = m.c.AliasedAs(alias)
	return m
}

func randInt() int64 {
	out := int64(new(maphash.Hash).Sum64())

	if out < 0 {
		return -out % 10000
	}

	return out % 10000
}

// ErrUniqueConstraint captures all unique constraint errors by explicitly leaving `s` empty.
var ErrUniqueConstraint = &UniqueConstraintError{s: ""}

type UniqueConstraintError struct {
	// s is a string uniquely identifying the constraint in the raw error message returned from the database.
	s string
}

func (e *UniqueConstraintError) Error() string {
	return e.s
}

func (e *UniqueConstraintError) Is(target error) bool {
	err, ok := target.(*sqliteDriver.Error)
	if !ok {
		return false
	}
	return err.Code() == 2067 && strings.Contains(err.Error(), e.s)
}
